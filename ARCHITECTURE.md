# Архитектура приложения "Ателье Новый Стиль"

## Общая структура приложения

Приложение представляет собой веб-систему для управления ателье с разделением на **бэкенд** (FastAPI) и **фронтенд** (HTML/CSS/JavaScript). Между ними есть прокси-сервер, который упрощает взаимодействие.

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│   Браузер   │ ──────> │  Прокси      │ ──────> │   Бэкенд    │
│  (Фронтенд) │ <────── │  Сервер      │ <────── │   (FastAPI) │
│             │         │  (Port 8080) │         │  (Port 8000)│
└─────────────┘         └──────────────┘         └─────────────┘
                                                         │
                                                         ▼
                                                  ┌─────────────┐
                                                  │ База данных │
                                                  │  (SQLite)   │
                                                  └─────────────┘
```

---

## 1. Взаимодействие бэкенда и фронтенда

### 1.1. Прокси-сервер (start_server.py)

**Назначение:** Прокси-сервер на порту 8080 служит промежуточным звеном между фронтендом и бэкендом.

**Основные функции:**
- **Раздача статических файлов** (HTML, CSS, JS) из директории `frontend/`
- **Проксирование API-запросов** к бэкенду:
  - Запросы к `/api/*` перенаправляются на `http://localhost:8000/*` (убирается префикс `/api`)
  - Запросы к `/uploads/*` также проксируются на бэкенд
- **Обработка CORS** (Cross-Origin Resource Sharing) - добавляет необходимые заголовки для кросс-доменных запросов
- **Маршрутизация:** 
  - Корневой путь `/` редиректит на `/frontend/templates/index.html`
  - Пути `/templates/*` и `/static/*` автоматически перенаправляются в `frontend/`

**Пример работы:**
```
Браузер запрашивает: GET http://localhost:8080/api/profile
Прокси перенаправляет: GET http://localhost:8000/profile
Бэкенд обрабатывает запрос и возвращает ответ
Прокси возвращает ответ браузеру
```

### 1.2. API URL на фронтенде

В файлах фронтенда (`auth.js`, `dashboard.js`, и др.) используется переменная `API_URL`:

```javascript
var API_URL = typeof window !== 'undefined' && window.location.port === '8080' 
    ? '/api'  // Используем прокси если фронтенд на порту 8080
    : 'http://localhost:8000/api';  // Прямой URL к бэкенду
```

**Логика:**
- Если фронтенд работает на порту 8080 (через прокси), используется относительный путь `/api`
- Если фронтенд работает напрямую, используется полный URL `http://localhost:8000/api`

### 1.3. Аутентификация (JWT токены)

**Механизм:**
1. Пользователь входит через `/api/auth/login` (фактически `/auth/login` на бэкенде)
2. Бэкенд возвращает JWT токен
3. Токен сохраняется в `localStorage` браузера
4. При каждом запросе токен добавляется в заголовок `Authorization: Bearer <token>`
5. Бэкенд проверяет токен и извлекает информацию о пользователе

**Класс AuthManager (auth.js):**
- `getToken()` - получение токена из localStorage
- `setToken(token)` - сохранение токена
- `removeToken()` - удаление токена (при выходе)
- `isAuthenticated()` - проверка наличия токена
- `getAuthHeader()` - формирование заголовка `Bearer <token>`
- `requireAuth()` - проверка авторизации и редирект на страницу входа

---

## 2. База данных и модели

### 2.1. Структура базы данных

База данных использует SQLite с асинхронным SQLAlchemy ORM. Основные таблицы:

#### **User** (Пользователи)
- `id` - уникальный идентификатор
- `email` - email (уникальный, используется для входа)
- `hashed_password` - хешированный пароль (bcrypt)
- `is_active` - активен ли пользователь
- `is_superuser` - является ли администратором
- `is_verified` - верифицирован ли email
- `created_at` - дата создания
- `updated_at` - дата обновления

#### **Profile** (Профили пользователей)
- `id` - уникальный идентификатор
- `user_id` - внешний ключ на User (один-к-одному)
- `name` - имя пользователя
- `phone` - телефон
- `age` - возраст
- `photo_filename` - имя файла фотографии

#### **Costume** (Костюмы)
- `id` - уникальный идентификатор
- `title` - название костюма
- `description` - описание
- `image_filename` - имя файла изображения
- `price` - цена за день проката
- `available` - доступен ли для бронирования

#### **Order** (Заявки/Заказы)
- `id` - уникальный идентификатор
- `user_id` - внешний ключ на User
- `costume_id` - внешний ключ на Costume (опционально)
- `title` - название заявки
- `status` - статус ("новая", "в обработке", "завершена")
- `created_at` - дата создания

#### **Reservation** (Бронирования)
- `id` - уникальный идентификатор
- `user_id` - внешний ключ на User
- `costume_id` - внешний ключ на Costume
- `date_from` - дата начала бронирования
- `date_to` - дата окончания бронирования
- `created_at` - дата создания бронирования

### 2.2. Связи между таблицами

- `User` ←→ `Profile`: один-к-одному (один пользователь имеет один профиль)
- `User` ←→ `Order`: один-ко-многим (один пользователь может иметь много заявок)
- `User` ←→ `Reservation`: один-ко-многим (один пользователь может иметь много бронирований)
- `Costume` ←→ `Order`: один-ко-многим (один костюм может быть связан с несколькими заявками)
- `Costume` ←→ `Reservation`: один-ко-многим (один костюм может иметь много бронирований)

---

## 3. API Эндпоинты (Backend)

### 3.1. Аутентификация (`/auth/*`)

#### **POST /auth/register**
- **Назначение:** Регистрация нового пользователя
- **Авторизация:** Не требуется
- **Тело запроса:**
  ```json
  {
    "email": "user@example.com",
    "password": "password123"
  }
  ```
- **Ответ:** Объект пользователя (без пароля)
- **Роутер:** FastAPI Users (автоматически генерируется)

#### **POST /auth/login**
- **Назначение:** Вход в систему
- **Авторизация:** Не требуется
- **Тело запроса:** FormData с `username` (email) и `password`
- **Ответ:** JWT токен
- **Роутер:** FastAPI Users

#### **POST /auth/logout**
- **Назначение:** Выход из системы
- **Авторизация:** Требуется (JWT токен)
- **Роутер:** FastAPI Users

#### **POST /auth/verify**
- **Назначение:** Проверка токена
- **Авторизация:** Требуется (JWT токен)
- **Роутер:** FastAPI Users

#### **POST /auth/register-simple**
- **Назначение:** Упрощенная регистрация (без использования FastAPI Users)
- **Авторизация:** Не требуется
- **Тело запроса:**
  ```json
  {
    "email": "user@example.com",
    "password": "password123"
  }
  ```
- **Ответ:**
  ```json
  {
    "message": "User created successfully",
    "user_id": 1,
    "email": "user@example.com"
  }
  ```

### 3.2. Чат (`/chat/*`)

#### **POST /chat**
- **Назначение:** Публичный чат (без авторизации)
- **Авторизация:** Не требуется
- **Тело запроса:**
  ```json
  {
    "text": "Какие услуги предоставляет ателье?"
  }
  ```
- **Логика работы:**
  1. Поиск ответа в базе знаний (`find_in_knowledge_base`)
  2. Если не найдено - использование Gemini AI (если настроен)
  3. Если Gemini недоступен - возврат случайного ответа из fallback
- **Ответ:**
  ```json
  {
    "response": "Ателье предоставляет следующие услуги..."
  }
  ```

#### **POST /chat/authenticated**
- **Назначение:** Защищенный чат для авторизованных пользователей
- **Авторизация:** Требуется (JWT токен)
- **Функциональность:** Аналогична `/chat`, но логирует email пользователя
- **Тело запроса:** То же, что и `/chat`

### 3.3. Профиль пользователя (`/profile/*`)

#### **GET /profile**
- **Назначение:** Получение профиля текущего пользователя
- **Авторизация:** Требуется (JWT токен)
- **Зависимость:** `current_active_user` - извлекает пользователя из JWT токена
- **Ответ:**
  ```json
  {
    "id": 1,
    "email": "user@example.com",
    "is_active": true,
    "is_verified": false,
    "is_superuser": false,
    "created_at": "2024-01-01T00:00:00",
    "name": "Иван Иванов",
    "phone": "+7 900 123 45 67",
    "age": 30,
    "photo_url": "/uploads/user_1_photo.jpg"
  }
  ```

#### **PUT /profile**
- **Назначение:** Обновление профиля пользователя
- **Авторизация:** Требуется (JWT токен)
- **Тело запроса:**
  ```json
  {
    "name": "Иван Иванов",
    "phone": "+7 900 123 45 67",
    "age": 30
  }
  ```
- **Валидация:** Возраст должен быть от 0 до 120
- **Логика:** Если профиль не существует, создается новый
- **Ответ:** `{"ok": true}`

#### **POST /profile/photo**
- **Назначение:** Загрузка фотографии профиля
- **Авторизация:** Требуется (JWT токен)
- **Тело запроса:** FormData с полем `image` (файл)
- **Валидация:** Разрешенные форматы - `.jpg`, `.jpeg`, `.png`
- **Логика:** 
  - Файл сохраняется в `backend/uploads/` с именем `user_{user_id}_{original_filename}`
  - Имя файла сохраняется в таблице `Profile`
- **Ответ:**
  ```json
  {
    "photo_url": "/uploads/user_1_photo.jpg"
  }
  ```

### 3.4. Заявки/Заказы (`/orders/*`)

#### **POST /orders** (CREATE)
- **Назначение:** Создание новой заявки
- **Авторизация:** Требуется (JWT токен)
- **Тело запроса:**
  ```json
  {
    "title": "Пошив платья",
    "status": "новая",
    "costume_id": 1  // опционально
  }
  ```
- **Валидация статуса:** Допустимые значения - "новая", "в обработке", "завершена"
- **Логика:** 
  - Если указан `costume_id`, проверяется существование костюма
  - Заявка связывается с текущим пользователем через `user_id`
- **Ответ:** Объект заявки (OrderOut)

#### **GET /orders/me** (READ)
- **Назначение:** Получение всех заявок текущего пользователя
- **Авторизация:** Требуется (JWT токен)
- **Ответ:** Массив заявок, отсортированных по дате создания (новые первыми)
  ```json
  [
    {
      "id": 1,
      "title": "Пошив платья",
      "status": "новая",
      "created_at": "2024-01-01T00:00:00",
      "costume_id": 1
    }
  ]
  ```

#### **GET /orders/all** (READ - Admin only)
- **Назначение:** Получение всех заявок всех пользователей
- **Авторизация:** Требуется (JWT токен + права администратора)
- **Зависимость:** `require_admin` - проверяет `is_superuser`
- **Ответ:** Массив заявок с информацией о пользователях
  ```json
  [
    {
      "id": 1,
      "user_id": 1,
      "user_email": "user@example.com",
      "title": "Пошив платья",
      "status": "новая",
      "created_at": "2024-01-01T00:00:00",
      "costume_id": 1,
      "costume_title": "Карнавальный костюм"
    }
  ]
  ```

#### **PATCH /orders/{order_id}/status** (UPDATE - Admin only)
- **Назначение:** Обновление статуса заявки
- **Авторизация:** Требуется (JWT токен + права администратора)
- **Параметры URL:** `order_id` - ID заявки
- **Тело запроса:**
  ```json
  {
    "status": "в обработке"
  }
  ```
- **Ответ:** Обновленный объект заявки

### 3.5. Костюмы (`/costumes/*`)

#### **POST /costumes** (CREATE - Admin only)
- **Назначение:** Создание нового костюма
- **Авторизация:** Требуется (JWT токен + права администратора)
- **Тело запроса:** FormData с полями:
  - `title` - название (обязательно)
  - `description` - описание (опционально)
  - `price` - цена (обязательно, число)
  - `available` - доступен ли (boolean, по умолчанию true)
  - `image` - файл изображения (обязательно)
- **Валидация:** Формат изображения - `.jpg`, `.jpeg`, `.png`
- **Логика:** 
  - Генерируется уникальное имя файла с UUID
  - Файл сохраняется в `backend/uploads/`
- **Ответ:** Объект костюма с `image_url`

#### **GET /costumes** (READ - Public)
- **Назначение:** Получение списка всех костюмов
- **Авторизация:** Не требуется
- **Ответ:** Массив всех костюмов с URL изображений

#### **GET /costumes/{costume_id}** (READ - Public)
- **Назначение:** Получение конкретного костюма по ID
- **Авторизация:** Не требуется
- **Параметры URL:** `costume_id` - ID костюма
- **Ответ:** Объект костюма
- **Ошибка:** 404, если костюм не найден

#### **PUT /costumes/{costume_id}** (UPDATE - Admin only)
- **Назначение:** Обновление костюма
- **Авторизация:** Требуется (JWT токен + права администратора)
- **Параметры URL:** `costume_id` - ID костюма
- **Тело запроса:** FormData (аналогично POST /costumes)
- **Логика:** 
  - Если загружено новое изображение, старое удаляется
  - Генерируется новое уникальное имя файла
- **Ответ:** Обновленный объект костюма

#### **DELETE /costumes/{costume_id}** (DELETE - Admin only)
- **Назначение:** Удаление костюма
- **Авторизация:** Требуется (JWT токен + права администратора)
- **Параметры URL:** `costume_id` - ID костюма
- **Ответ:** `{"ok": true}`
- **Примечание:** Файл изображения не удаляется (можно улучшить)

#### **GET /costumes/{costume_id}/availability**
- **Назначение:** Проверка доступности костюма на определенные даты
- **Авторизация:** Не требуется
- **Параметры URL:** `costume_id` - ID костюма
- **Query параметры:** 
  - `from_date` (опционально) - дата начала
  - `to_date` (опционально) - дата окончания
- **Ответ:** Массив бронирований, которые пересекаются с указанными датами

### 3.6. Бронирования (`/reservations/*`)

#### **POST /reservations** (CREATE)
- **Назначение:** Создание нового бронирования
- **Авторизация:** Требуется (JWT токен)
- **Тело запроса:**
  ```json
  {
    "costume_id": 1,
    "date_from": "2024-01-01",
    "date_to": "2024-01-05"
  }
  ```
- **Валидация:**
  - `date_to` не может быть раньше `date_from`
  - Костюм должен существовать и быть доступным (`available = true`)
  - Не должно быть пересечений с существующими бронированиями
- **Ошибка:** 409 Conflict, если даты пересекаются
- **Ответ:** Объект бронирования

#### **GET /reservations/me** (READ)
- **Назначение:** Получение всех бронирований текущего пользователя
- **Авторизация:** Требуется (JWT токен)
- **Ответ:** Массив бронирований, отсортированных по дате (новые первыми)

#### **GET /reservations/all** (READ - Admin only)
- **Назначение:** Получение всех бронирований всех пользователей
- **Авторизация:** Требуется (JWT токен + права администратора)
- **Ответ:** Массив бронирований с информацией о пользователях и костюмах

#### **DELETE /reservations/{reservation_id}** (DELETE - Admin only)
- **Назначение:** Удаление бронирования
- **Авторизация:** Требуется (JWT токен + права администратора)
- **Параметры URL:** `reservation_id` - ID бронирования
- **Ответ:** `{"ok": true}`

---

## 4. CRUD операции

### 4.1. CRUD для Заявок (Orders)

| Операция | Метод | Эндпоинт | Авторизация | Доступ |
|----------|-------|----------|-------------|--------|
| **Create** | POST | `/orders` | JWT | Все пользователи |
| **Read (мои)** | GET | `/orders/me` | JWT | Все пользователи |
| **Read (все)** | GET | `/orders/all` | JWT + Admin | Только админы |
| **Update (статус)** | PATCH | `/orders/{id}/status` | JWT + Admin | Только админы |
| **Delete** | - | - | - | Не реализовано |

### 4.2. CRUD для Костюмов (Costumes)

| Операция | Метод | Эндпоинт | Авторизация | Доступ |
|----------|-------|----------|-------------|--------|
| **Create** | POST | `/costumes` | JWT + Admin | Только админы |
| **Read (все)** | GET | `/costumes` | - | Публичный |
| **Read (один)** | GET | `/costumes/{id}` | - | Публичный |
| **Update** | PUT | `/costumes/{id}` | JWT + Admin | Только админы |
| **Delete** | DELETE | `/costumes/{id}` | JWT + Admin | Только админы |

### 4.3. CRUD для Бронирований (Reservations)

| Операция | Метод | Эндпоинт | Авторизация | Доступ |
|----------|-------|----------|-------------|--------|
| **Create** | POST | `/reservations` | JWT | Все пользователи |
| **Read (мои)** | GET | `/reservations/me` | JWT | Все пользователи |
| **Read (все)** | GET | `/reservations/all` | JWT + Admin | Только админы |
| **Update** | - | - | - | Не реализовано |
| **Delete** | DELETE | `/reservations/{id}` | JWT + Admin | Только админы |

### 4.4. CRUD для Профилей (Profiles)

| Операция | Метод | Эндпоинт | Авторизация | Доступ |
|----------|-------|----------|-------------|--------|
| **Create** | - | - | - | Создается автоматически при обновлении |
| **Read** | GET | `/profile` | JWT | Все пользователи |
| **Update** | PUT | `/profile` | JWT | Все пользователи |
| **Delete** | - | - | - | Не реализовано |
| **Upload Photo** | POST | `/profile/photo` | JWT | Все пользователи |

---

## 5. Основные функции бэкенда

### 5.1. Аутентификация и авторизация

#### **current_active_user** (из `auth.py`)
- **Назначение:** Зависимость FastAPI для извлечения текущего пользователя из JWT токена
- **Использование:** Добавляется в параметры эндпоинта через `Depends(current_active_user)`
- **Логика:**
  1. Извлекает токен из заголовка `Authorization: Bearer <token>`
  2. Проверяет валидность токена
  3. Извлекает ID пользователя из токена
  4. Загружает пользователя из базы данных
  5. Проверяет, что пользователь активен (`is_active = true`)
  6. Возвращает объект пользователя или вызывает исключение 401

#### **require_admin** (из `main.py`)
- **Назначение:** Зависимость для проверки прав администратора
- **Логика:**
  1. Использует `current_active_user` для получения пользователя
  2. Проверяет `user.is_superuser`
  3. Если не админ - вызывает исключение 403 (Forbidden)
  4. Возвращает пользователя, если он админ

### 5.2. База знаний и чат

#### **preprocess_text(text: str)**
- **Назначение:** Предобработка текста для поиска в базе знаний
- **Логика:**
  1. Приводит текст к нижнему регистру
  2. Удаляет знаки препинания (заменяет на пробелы)
  3. Удаляет множественные пробелы
- **Пример:** `"Привет, мир!"` → `"привет мир"`

#### **find_in_knowledge_base(user_input: str)**
- **Назначение:** Поиск ответа в базе знаний
- **Логика:**
  1. Предобрабатывает ввод пользователя
  2. Проверяет приветствия (возвращает стандартное приветствие)
  3. Проверяет общие вопросы (возвращает общий ответ)
  4. Ищет точные совпадения терминов
  5. Ищет по ключевым словам в вопросах (находит вопрос с наибольшим количеством совпадений)
- **Возвращает:** Ответ из базы знаний или `None`

### 5.3. Работа с базой данных

#### **get_async_session()**
- **Назначение:** Генератор для получения сессии базы данных
- **Использование:** `Depends(get_async_session)` в эндпоинтах
- **Логика:** Создает новую асинхронную сессию SQLAlchemy для каждого запроса

#### **create_tables()**
- **Назначение:** Создание всех таблиц в базе данных
- **Вызывается:** При запуске приложения (в `lifespan`)
- **Логика:**
  1. Создает все таблицы из моделей SQLAlchemy
  2. Выполняет миграцию недостающих колонок

#### **migrate_missing_columns()**
- **Назначение:** Добавление недостающих колонок в существующие таблицы
- **Пример:** Добавляет колонку `costume_id` в таблицу `orders`, если её нет

### 5.4. Обработка файлов

#### **Загрузка файлов (uploads/)**
- **Директория:** `backend/uploads/`
- **Типы файлов:**
  - Фотографии профилей: `user_{user_id}_{filename}`
  - Изображения костюмов: `{uuid}.{ext}`
- **Валидация:** Только `.jpg`, `.jpeg`, `.png`
- **Доступ:** Файлы доступны через `/uploads/{filename}` (статический роут FastAPI)

### 5.5. Инициализация приложения

#### **lifespan(app: FastAPI)**
- **Назначение:** Контекстный менеджер для действий при запуске/остановке
- **При запуске:**
  1. Создает таблицы базы данных
  2. Создает/обновляет суперпользователя (админа) из переменных окружения:
     - `SUPERUSER_EMAIL` - email админа
     - `SUPERUSER_PASSWORD` - пароль админа
     - `SUPERUSER_FORCE_PASSWORD` - принудительное обновление пароля

---

## 6. Основные функции фронтенда

### 6.1. Управление аутентификацией (auth.js)

#### **AuthManager**
- **Класс:** Синглтон для управления аутентификацией
- **Методы:**
  - `getToken()` - получение токена из localStorage
  - `setToken(token)` - сохранение токена
  - `removeToken()` - удаление токена
  - `isAuthenticated()` - проверка наличия токена
  - `getAuthHeader()` - формирование заголовка Authorization
  - `requireAuth()` - проверка авторизации с редиректом
  - `redirectIfAuthenticated()` - редирект, если уже авторизован

#### **apiRequest(url, options)**
- **Назначение:** Обертка для HTTP запросов
- **Логика:**
  1. Выполняет fetch запрос
  2. Парсит JSON ответ
  3. Проверяет статус ответа
  4. Выбрасывает ошибку, если запрос неуспешен
- **Использование:** Упрощает обработку ошибок в других модулях

### 6.2. Личный кабинет (dashboard.js)

#### **loadUserProfile()**
- **Назначение:** Загрузка профиля пользователя
- **API:** `GET /api/profile`
- **Логика:**
  1. Получает токен из AuthManager
  2. Отправляет GET запрос с заголовком Authorization
  3. Обрабатывает ошибки (401 - редирект на логин)
  4. Отображает данные в интерфейсе через `displayUserInfo()`

#### **loadUserOrders()**
- **Назначение:** Загрузка заявок пользователя
- **API:** `GET /api/orders/me`
- **Логика:** Аналогична `loadUserProfile()`
- **Отображение:** Рендеринг таблицы через `renderOrdersTable()`

#### **setupProfileForm()**
- **Назначение:** Настройка формы обновления профиля
- **API:** `PUT /api/profile`
- **Логика:**
  1. Слушает событие submit формы
  2. Собирает данные формы
  3. Отправляет PUT запрос
  4. Обновляет интерфейс при успехе

### 6.3. Формы заказов (order-forms.js)

#### **submitOrder(formData, orderType)**
- **Назначение:** Отправка заявки на сервер
- **API:** `POST /api/orders`
- **Параметры:**
  - `formData` - объект с данными формы (date, phone, material, comment)
  - `orderType` - тип заказа (например, "Пошив одежды")
- **Логика:**
  1. Проверяет наличие токена
  2. Формирует `title` из типа заказа и материала
  3. Отправляет POST запрос с телом `{title, status: "новая"}`
  4. Возвращает созданную заявку

#### **handleOrderFormSubmit(e)**
- **Назначение:** Обработчик отправки формы заказа
- **Логика:**
  1. Предотвращает стандартную отправку формы
  2. Собирает данные формы через `getFormData()`
  3. Проверяет авторизацию
  4. Вызывает `submitOrder()`
  5. Показывает сообщение об успехе/ошибке
  6. Обновляет список заявок, если открыт личный кабинет

#### **initOrderForms()**
- **Назначение:** Инициализация всех форм заказов на странице
- **Логика:** Находит все формы с ID, начинающимся с `sewOrderForm`, и добавляет обработчики

### 6.4. Каталог костюмов (costumes.js)

#### **loadCostumes()**
- **Назначение:** Загрузка списка костюмов
- **API:** `GET /api/costumes`
- **Логика:**
  1. Отправляет GET запрос (публичный, без авторизации)
  2. Рендерит сетку костюмов для пользователей через `renderUserGrid()`
  3. Если пользователь админ - рендерит админ-таблицу через `renderAdminTable()`

#### **renderUserGrid(items)**
- **Назначение:** Отображение костюмов в виде карточек
- **Логика:**
  1. Создает HTML карточки для каждого костюма
  2. Добавляет кнопку "Заказать" (если костюм доступен)
  3. Подключает обработчик клика для открытия модального окна бронирования

#### **renderAdminTable(items)**
- **Назначение:** Отображение костюмов в виде таблицы для админов
- **Логика:**
  1. Создает таблицу с кнопками "Редактировать" и "Удалить"
  2. При клике на "Редактировать" - загружает данные костюма в форму
  3. При клике на "Удалить" - отправляет DELETE запрос

#### **Отправка формы костюма (для админов)**
- **API:** `POST /api/costumes` (создание) или `PUT /api/costumes/{id}` (обновление)
- **Логика:**
  1. Собирает данные формы в FormData
  2. Отправляет запрос с файлом изображения
  3. Обновляет список костюмов при успехе

#### **Бронирование костюма**
- **API:** `POST /api/reservations`
- **Логика:**
  1. Открывается модальное окно при клике на "Заказать"
  2. Пользователь выбирает даты
  3. Проверяется доступность костюма на эти даты
  4. Отправляется POST запрос с данными бронирования
  5. Показывается сообщение об успехе/ошибке

### 6.5. Чат-виджет (chat-widget.js)

#### **ChatWidget**
- **Класс:** Виджет чата для взаимодействия с AI
- **Методы:**
  - `toggle()` - открытие/закрытие виджета
  - `addMessage(text, sender)` - добавление сообщения в чат
  - `sendMessage()` - отправка сообщения на сервер

#### **sendMessage()**
- **API:** `POST /api/chat` (публичный) или `POST /api/chat/authenticated` (если авторизован)
- **Логика:**
  1. Получает текст из поля ввода
  2. Добавляет сообщение пользователя в чат
  3. Показывает индикатор "Думаю..."
  4. Отправляет POST запрос
  5. Удаляет индикатор и добавляет ответ бота
  6. Обрабатывает ошибки сети

### 6.6. Страницы входа и регистрации

#### **login.js**
- **Функция входа:**
  1. Собирает email и password из формы
  2. Отправляет POST запрос на `/api/auth/login` (FormData)
  3. Сохраняет токен через `AuthManager.setToken()`
  4. Редиректит на главную страницу

#### **register.js**
- **Функция регистрации:**
  1. Собирает email и password из формы
  2. Отправляет POST запрос на `/api/auth/register`
  3. При успехе - редирект на страницу входа
  4. При ошибке - показывает сообщение об ошибке

---

## 7. Поток данных в приложении

### 7.1. Пример: Создание заявки

```
1. Пользователь заполняет форму на фронтенде
   └─> order-forms.js: handleOrderFormSubmit()

2. Фронтенд собирает данные и проверяет авторизацию
   └─> AuthManager.getToken() - получает JWT токен

3. Фронтенд отправляет POST запрос
   └─> POST /api/orders
   └─> Headers: Authorization: Bearer <token>
   └─> Body: {title: "...", status: "новая"}

4. Прокси-сервер перенаправляет запрос
   └─> POST http://localhost:8000/orders

5. Бэкенд обрабатывает запрос
   └─> main.py: create_order()
   └─> Depends(current_active_user) - проверяет токен и получает пользователя
   └─> Depends(get_async_session) - получает сессию БД
   └─> Создает объект Order в БД
   └─> Возвращает OrderOut

6. Ответ проходит обратно через прокси
   └─> Прокси добавляет CORS заголовки

7. Фронтенд получает ответ
   └─> Показывает сообщение об успехе
   └─> Обновляет список заявок (если открыт личный кабинет)
```

### 7.2. Пример: Загрузка профиля

```
1. Пользователь открывает личный кабинет
   └─> dashboard.js: DOMContentLoaded

2. Фронтенд проверяет авторизацию
   └─> AuthManager.requireAuth()

3. Фронтенд отправляет GET запрос
   └─> GET /api/profile
   └─> Headers: Authorization: Bearer <token>

4. Прокси перенаправляет на бэкенд
   └─> GET http://localhost:8000/profile

5. Бэкенд обрабатывает запрос
   └─> main.py: get_profile()
   └─> Depends(current_active_user) - получает пользователя из токена
   └─> Загружает Profile из БД (если есть)
   └─> Формирует ответ с данными пользователя и профиля

6. Фронтенд получает данные
   └─> displayUserInfo(userData) - отображает в интерфейсе
```

### 7.3. Пример: Чат с AI

```
1. Пользователь вводит вопрос в чат
   └─> chat-widget.js: sendMessage()

2. Фронтенд отправляет POST запрос
   └─> POST /api/chat
   └─> Body: {text: "..."}

3. Бэкенд обрабатывает запрос
   └─> main.py: chat_endpoint()
   └─> find_in_knowledge_base() - ищет в базе знаний
   └─> Если не найдено - использует Gemini AI
   └─> Если Gemini недоступен - возвращает fallback ответ

4. Фронтенд получает ответ
   └─> addMessage(data.response, 'bot') - отображает ответ
```

---

## 8. Безопасность

### 8.1. Аутентификация
- **JWT токены** - используются для аутентификации
- **Хеширование паролей** - bcrypt для безопасного хранения паролей
- **Проверка токена** - каждый защищенный эндпоинт проверяет валидность токена

### 8.2. Авторизация
- **Роли пользователей:**
  - Обычный пользователь - может создавать заявки, бронирования, просматривать свой профиль
  - Администратор (`is_superuser = true`) - полный доступ ко всем ресурсам
- **Защита эндпоинтов:** `Depends(require_admin)` для админ-функций

### 8.3. Валидация данных
- **Pydantic модели** - автоматическая валидация входных данных
- **Проверка форматов файлов** - только `.jpg`, `.jpeg`, `.png`
- **Проверка диапазонов** - возраст от 0 до 120, даты бронирования

### 8.4. CORS
- **Настройка:** Разрешены запросы с любого домена (`allow_origins=["*"]`)
- **В продакшене:** Следует ограничить домены

---

## 9. Зависимости и переменные окружения

### 9.1. Основные зависимости бэкенда
- `fastapi` - веб-фреймворк
- `sqlalchemy` - ORM для работы с БД
- `aiosqlite` - асинхронный драйвер SQLite
- `fastapi-users` - библиотека для аутентификации
- `python-jose` - работа с JWT токенами
- `passlib[bcrypt]` - хеширование паролей
- `google-generativeai` - интеграция с Gemini AI
- `python-multipart` - обработка файлов

### 9.2. Переменные окружения (.env)
- `GEMINI_API_KEY` - API ключ для Gemini AI (опционально)
- `SUPERUSER_EMAIL` - email администратора
- `SUPERUSER_PASSWORD` - пароль администратора
- `SUPERUSER_FORCE_PASSWORD` - принудительное обновление пароля (true/false)

---

## 10. Запуск приложения

### 10.1. Запуск бэкенда
```bash
cd backend
uvicorn main:app --reload --port 8000
```

### 10.2. Запуск прокси-сервера (фронтенд)
```bash
python start_server.py
```

### 10.3. Доступ к приложению
- **Фронтенд:** http://localhost:8080
- **Бэкенд API:** http://localhost:8000
- **Документация API:** http://localhost:8000/docs (Swagger UI)

---

## 11. Заключение

Приложение построено по архитектуре **клиент-сервер** с разделением на фронтенд и бэкенд. Взаимодействие происходит через REST API с использованием JWT токенов для аутентификации. Прокси-сервер упрощает разработку, позволяя работать с относительными путями на фронтенде.

Основные возможности:
- ✅ Аутентификация и авторизация пользователей
- ✅ Управление профилями пользователей
- ✅ Создание и управление заявками
- ✅ Каталог костюмов с бронированием
- ✅ Чат-бот с базой знаний и интеграцией AI
- ✅ Админ-панель для управления контентом

